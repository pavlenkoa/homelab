# HashiCorp Vault Complete configuration for homelab
# This includes Vault server + auto-unseal capabilities

# Auto-unseal configuration
autoUnseal:
  enabled: true
  
  # RBAC configuration
  rbac:
    create: true
    serviceAccountName: "vault-auto-unseal"
  
  # One-time initialization job (helm hook)
  image: "hashicorp/vault:1.15.2"

# Vault subchart configuration
vault:
  # Global configuration
  global:
    enabled: true

  # Server configuration
  server:
    # Disable development mode for production setup with auto-unseal
    dev:
      enabled: false
    
    # Single instance for homelab with persistent storage
    standalone:
      enabled: true
      config: |
        ui = true

        listener "tcp" {
          tls_disable = 1
          address = "[::]:8200"
          cluster_address = "[::]:8201"
          # Enable unauthenticated metrics access (necessary for Prometheus Operator)
          telemetry {
            unauthenticated_metrics_access = "true"
          }
        }
        
        storage "file" {
          path = "/vault/data"
        }

        # Telemetry for monitoring
        telemetry {
          prometheus_retention_time = "30s"
          disable_hostname = true
        }

    # ClusterIP service (will use ingress later)
    service:
      type: ClusterIP
      port: 8200

    # Data storage (required for standalone mode)
    dataStorage:
      enabled: true
      size: 2Gi
      storageClass: null
      accessMode: ReadWriteOnce
    
    # Auto-unseal postStart hook - unseals immediately on container start
    postStart:
      - sh
      - -c
      - |
        echo "üîì Starting Vault auto-unseal..."
        
        # Wait for Vault to be ready
        until vault status > /dev/null 2>&1; do
          echo "Waiting for Vault to start..."
          sleep 2
        done
        
        # Check if Vault is sealed
        if vault status | grep -q "Sealed.*true"; then
          echo "üîê Vault is sealed, attempting to unseal..."
          
          # Check if unseal keys secret exists
          if kubectl get secret vault-unseal-keys -n vault > /dev/null 2>&1; then
            echo "üìã Retrieving unseal keys..."
            
            # Get unseal keys
            UNSEAL_KEY_1=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.unseal-key-1}' | base64 -d)
            UNSEAL_KEY_2=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.unseal-key-2}' | base64 -d)
            UNSEAL_KEY_3=$(kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.unseal-key-3}' | base64 -d)
            
            # Unseal with 3 keys (threshold)
            vault operator unseal -format=json "$UNSEAL_KEY_1" > /dev/null 2>&1
            vault operator unseal -format=json "$UNSEAL_KEY_2" > /dev/null 2>&1
            vault operator unseal -format=json "$UNSEAL_KEY_3" > /dev/null 2>&1
            
            if vault status | grep -q "Sealed.*false"; then
              echo "‚úÖ Vault successfully unsealed!"
            else
              echo "‚ùå Failed to unseal Vault"
            fi
          else
            echo "‚ö†Ô∏è  Unseal keys secret not found - Vault may need initialization"
          fi
        else
          echo "‚úÖ Vault is already unsealed"
        fi
        
        echo "üîì Auto-unseal process completed"

    # Resource limits for single-node cluster
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 500m

    # Readiness and liveness probes
    readinessProbe:
      enabled: true
      path: "/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"
    livenessProbe:
      enabled: true
      path: "/v1/sys/health?standbyok=true"
      initialDelaySeconds: 60

    # Service account with RBAC permissions for managing secrets
    serviceAccount:
      create: false  # We'll use the custom service account with RBAC
      name: "vault-auto-unseal"
    
    # Extra volumes and mounts for kubectl access in postStart hook
    volumes:
      - name: kubectl-binary
        emptyDir: {}
    
    volumeMounts:
      - name: kubectl-binary
        mountPath: /usr/local/bin/kubectl
        subPath: kubectl
    
    # Init container to install kubectl for postStart hook
    extraInitContainers:
      - name: install-kubectl
        image: alpine:latest
        command:
          - sh
          - -c
          - |
            apk add --no-cache curl
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            cp kubectl /shared/kubectl
        volumeMounts:
          - name: kubectl-binary
            mountPath: /shared

  # UI configuration
  ui:
    enabled: true
    serviceType: "ClusterIP"

  # Injector configuration (for secret injection)
  injector:
    enabled: true
    
    # Resource limits for injector
    resources:
      requests:
        memory: 64Mi
        cpu: 50m
      limits:
        memory: 128Mi
        cpu: 250m

    # Agent configuration for sidecar injection
    agentImage:
      repository: "hashicorp/vault"
      tag: "1.15.2"

  # CSI driver (optional for homelab)
  csi:
    enabled: false