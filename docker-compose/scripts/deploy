#!/usr/bin/env bash
set -euo pipefail

# Deploy CLI Tool for Homelab Infrastructure
# Part of the new override-based deployment system

# Colors and symbols for clean output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[0;37m'
readonly RESET='\033[0m'

readonly ARROW_RIGHT="→"
readonly ARROW_LEFT="←"
readonly ARROW_UP="↑"
readonly ARROW_DOWN="↓"
readonly CHECK="✔"
readonly CROSS="✗"
readonly WARNING="⚠"
readonly INFO="ℹ"
readonly PLUS="[+]"
readonly HAMMER="⚒"

# Auto-detect environment from current directory
detect_environment() {
    local current_dir
    current_dir=$(basename "$(pwd)")
    
    case "$current_dir" in
        wroclaw|kyiv|oracle|frankfurt)
            echo "$current_dir"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Auto-discover services (*.yaml files excluding docker-compose.yaml)
discover_services() {
    find . -maxdepth 1 -name "*.yaml" -not -name "docker-compose.yaml" 2>/dev/null | sed 's|./||; s|.yaml||' | sort
}

# Display help information
show_help() {
    local command="${1:-}"
    
    if [[ -z "$command" ]]; then
        cat << 'EOF'
Deploy CLI Tool for Homelab Infrastructure

USAGE:
    ./deploy <service> <action> [options]
    ./deploy <action>           # Apply to all services

ACTIONS:
    setup           Generate environment configs and secrets
    up              Start service(s)
    down            Stop service(s) 
    restart         Restart service(s)
    logs            Show service logs
    status          Show service status
    clean           Stop service and clean generated files

SERVICE-SPECIFIC ACTIONS:
    authelia get-code           Extract verification codes
    authelia generate-secrets   Create JWT/session/storage secrets
    authelia generate-password  Generate random password and hash
    authelia clean-db           Remove database (needed after secret changes)
    caddy validate              Validate Caddyfile syntax
    monitoring backup           Backup critical monitoring data

EXAMPLES:
    ./deploy setup              # Setup all services
    ./deploy up                 # Start all services
    ./deploy caddy up           # Start only Caddy
    ./deploy authelia logs      # Show Authelia logs
    ./deploy authelia get-code  # Get Authelia verification code

ENVIRONMENT:
    Auto-detected from directory name: wroclaw, kyiv, oracle, frankfurt
    Override with: ENVIRONMENT=<name> ./deploy <command>

For service-specific help: ./deploy <service> help
EOF
    else
        case "$command" in
            authelia)
                cat << 'EOF'
Authelia Service Commands

ACTIONS:
    up, down, restart, logs, status, clean    # Standard service actions
    
AUTHELIA-SPECIFIC:
    get-code                          # Extract current verification code
    generate-secrets                  # Generate JWT, session, storage secrets
    generate-password [password]      # Generate password hash (random if not provided)
    clean-db                          # Remove database (needed after secret changes)
    
EXAMPLES:
    ./deploy authelia up
    ./deploy authelia get-code
    ./deploy authelia generate-password mypassword
    ./deploy authelia clean
    ./deploy authelia clean-db
EOF
                ;;
            caddy)
                cat << 'EOF'
Caddy Service Commands

ACTIONS:
    up, down, restart, logs, status    # Standard service actions
    
CADDY-SPECIFIC:
    validate                          # Validate Caddyfile syntax
    
EXAMPLES:
    ./deploy caddy up
    ./deploy caddy validate
EOF
                ;;
            monitoring)
                cat << 'EOF'
Monitoring Service Commands

ACTIONS:
    up, down, restart, logs, status    # Standard service actions
    
MONITORING-SPECIFIC:
    backup                            # Backup critical monitoring data
    
EXAMPLES:
    ./deploy monitoring up
    ./deploy monitoring backup
EOF
                ;;
            *)
                echo -e "${RED}${CROSS}${RESET} Unknown service: $command"
                echo "Available services: $(discover_services | tr '\n' ' ')"
                return 1
                ;;
        esac
    fi
}

# Professional logging functions without timestamps (let Docker handle its own output)
msg() {
    local level="$1"
    shift
    local message="$*"
    
    case "$level" in
        info)
            echo -e "${CYAN}•${RESET} ${message}"
            ;;
        success)
            echo -e "${GREEN}✓${RESET} ${message}"
            ;;
        warning)
            echo -e "${YELLOW}!${RESET} ${message}"
            ;;
        error)
            echo -e "${RED}✗${RESET} ${message}"
            ;;
        action)
            echo -e "${BLUE}→${RESET} ${message}"
            ;;
    esac
}

# Check if service exists
service_exists() {
    local service="$1"
    [[ -f "${service}.yaml" ]]
}

# Generate docker-compose command with proper file ordering
compose_cmd() {
    local service="$1"
    local base_file="../_base/${service}.yaml"
    local override_file="${service}.yaml"
    
    # Use service-specific project name to avoid conflicts
    local project_name="${service}"
    local cmd="docker compose --project-name $project_name"
    
    # Add base file if it exists
    if [[ -f "$base_file" ]]; then
        cmd="$cmd -f $base_file"
    fi
    
    # Add override file if it exists
    if [[ -f "$override_file" ]]; then
        cmd="$cmd -f $override_file"
    fi
    
    # Add environment files if they exist
    if [[ -f ".env.generated" ]]; then
        cmd="$cmd --env-file .env.generated"
    fi
    if [[ -f ".env.user" ]]; then
        cmd="$cmd --env-file .env.user"
    fi
    
    echo "$cmd"
}

# Load environment variables from .env files
load_env_vars() {
    local env_vars=()
    
    # Helper function to parse env file
    parse_env_file() {
        local file="$1"
        while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$key" ]] && continue
            # Remove quotes if present
            value="${value#\"}"
            value="${value%\"}"
            value="${value#\'}"
            value="${value%\'}"
            env_vars+=("$key=$value")
        done < "$file"
    }
    
    [[ -f ".env.generated" ]] && parse_env_file ".env.generated"
    [[ -f ".env.user" ]] && parse_env_file ".env.user"
    
    printf '%s\n' "${env_vars[@]}"
}

# Process template files with environment variable substitution
process_templates() {
    local service="${1:-}"
    
    # Find template files
    local template_files=()
    if [[ -n "$service" ]]; then
        # Process templates for specific service only
        while IFS= read -r -d '' file; do
            template_files+=("$file")
        done < <(find "$service" -name "*.tmpl" -print0 2>/dev/null || true)
    else
        # Process templates for all services (only used during initial setup)
        while IFS= read -r -d '' file; do
            template_files+=("$file")
        done < <(find . -name "*.tmpl" -print0 2>/dev/null || true)
    fi
    
    if [[ ${#template_files[@]} -eq 0 ]]; then
        [[ -n "$service" ]] && msg info "No .tmpl files found for service: $service"
        return 0
    fi
    
    # Load environment variables once
    local env_vars
    env_vars=$(load_env_vars)
    
    local processed=0
    local failed=0
    local skipped=0
    
    # Only show output for setup, be quiet for service actions
    local quiet="${2:-false}"
    
    if [[ "$quiet" != "true" ]]; then
        if [[ ${#template_files[@]} -eq 1 ]]; then
            echo -e "${BLUE}→${RESET} Generating config from template..."
        else
            echo -e "${BLUE}→${RESET} Generating ${#template_files[@]} configs from templates..."
        fi
    fi
    
    # Process each template file
    for template_file in "${template_files[@]}"; do
        local output_file="${template_file%.tmpl}"
        local short_template="${template_file#./}"
        local short_output="${output_file#./}"
        
        # Check if template processing is needed
        local needs_processing=true
        if [[ -f "$output_file" && -f ".env.generated" ]]; then
            # Check if output file is newer than both template and .env.generated
            if [[ "$output_file" -nt "$template_file" && "$output_file" -nt ".env.generated" ]]; then
                needs_processing=false
            fi
        fi
        
        if [[ "$needs_processing" == "false" ]]; then
            if [[ "$quiet" != "true" ]]; then
                echo -e "  ${WHITE}✓${RESET} $short_template → $short_output (no changes)"
            fi
            ((skipped++))
            continue
        fi
        
        # Start with template content
        local content
        content=$(cat "$template_file")
        
        # Replace all {{VARIABLE}} placeholders
        while IFS='=' read -r key value; do
            [[ -z "$key" ]] && continue
            
            # Special handling for JWKS key - decode base64 and indent properly
            if [[ "$key" == "AUTHELIA_OIDC_JWKS_KEY" ]]; then
                local decoded_key temp_file
                temp_file=$(mktemp)
                echo "$value" | base64 -d | sed 's/^/          /' > "$temp_file"
                # Use awk to replace the placeholder with the multiline content
                content=$(awk -v key="{{$key}}" -v file="$temp_file" '
                    {
                        if ($0 ~ key) {
                            while ((getline line < file) > 0) {
                                print line
                            }
                            close(file)
                        } else {
                            print $0
                        }
                    }
                ' <<< "$content")
                rm -f "$temp_file"
            else
                # Escape special characters in value for sed (use | as delimiter to avoid issues with /)
                local escaped_value
                escaped_value=$(printf '%s\n' "$value" | sed 's/[[\.*^$()+?{|]/\\&/g')
                # Replace {{KEY}} with value using | as delimiter
                content=$(printf '%s\n' "$content" | sed "s|{{$key}}|$escaped_value|g")
            fi
        done <<< "$env_vars"
        
        # Write processed content to output file
        if printf '%s\n' "$content" > "$output_file"; then
            if [[ "$quiet" != "true" ]]; then
                echo -e "  ${WHITE}✓${RESET} $short_template → $short_output"
            fi
            ((processed++))
        else
            if [[ "$quiet" != "true" ]]; then
                echo -e "  ${RED}✗${RESET} $short_template → $short_output"
            fi
            ((failed++))
        fi
    done
    
    # Show summary for non-quiet mode
    if [[ "$quiet" != "true" ]]; then
        local total=$((processed + failed + skipped))
        if [[ $processed -gt 0 || $failed -gt 0 ]]; then
            if [[ $failed -eq 0 ]]; then
                if [[ $skipped -gt 0 ]]; then
                    echo -e "\n${GREEN}✓${RESET} Successfully rendered $processed/$total files (${skipped} unchanged)"
                else
                    echo -e "\n${GREEN}✓${RESET} Successfully rendered $processed/$total files"
                fi
            else
                echo -e "\n${RED}✗${RESET} Rendered $processed/$total files (${failed} failed, ${skipped} unchanged)"
            fi
        else
            echo -e "\n${CYAN}•${RESET} No template changes needed"
        fi
    fi
    
    [[ $failed -eq 0 ]]
}

# Check if service has secrets in .env.generated
service_has_secrets() {
    local service="$1"
    local service_capitalized
    service_capitalized="$(echo "${service:0:1}" | tr '[:lower:]' '[:upper:]')${service:1}"
    [[ -f ".env.generated" ]] && grep -q "# ${service_capitalized} secrets" .env.generated
}

# Remove service-specific secrets from .env.generated
remove_service_secrets() {
    local service="$1"
    local service_capitalized
    service_capitalized="$(echo "${service:0:1}" | tr '[:lower:]' '[:upper:]')${service:1}"
    
    if [[ ! -f ".env.generated" ]]; then
        return 0
    fi
    
    # Create temporary file without the service secrets section
    local temp_file
    temp_file=$(mktemp)
    
    # Use awk to remove the service secrets section and clean up excessive blank lines
    awk -v service="$service_capitalized" '
    BEGIN { in_section = 0; blank_lines = 0 }
    /^# [A-Za-z]+ secrets$/ {
        if ($2 == service) {
            in_section = 1
            # Skip the blank line before this section too
            blank_lines = 0
            next
        } else {
            in_section = 0
        }
    }
    /^# / && !/^# [A-Za-z]+ secrets$/ {
        in_section = 0
    }
    /^$/ {
        if (in_section) {
            next
        } else {
            blank_lines++
            if (blank_lines <= 1) {
                print
            }
            next
        }
    }
    /^[^#]/ {
        blank_lines = 0
        if (in_section && /^[A-Z_]+=/) {
            next
        }
    }
    !in_section {
        blank_lines = 0
        print
    }
    ' .env.generated > "$temp_file"
    
    # Replace original file if changes were made
    if ! cmp -s .env.generated "$temp_file"; then
        mv "$temp_file" .env.generated
        echo -e "  ${CYAN}•${RESET} .env.generated ($service secrets)"
    else
        rm -f "$temp_file"
    fi
}

# Generate secrets for a specific service
generate_service_secrets() {
    local service="$1"
    local environment
    environment=$(detect_environment)
    
    # Ensure .env.generated exists with basic structure
    if [[ ! -f ".env.generated" ]]; then
        cat > .env.generated << EOF
# Auto-generated secrets - DO NOT EDIT MANUALLY
# Generated on $(date)
ENVIRONMENT=$environment
EOF
    fi
    
    # Generate secrets based on service type
    case "$service" in
        authelia)
            if ! service_has_secrets "authelia"; then
                echo -e "${BLUE}→${RESET} Generating Authelia secrets..."
                echo -e "${BLUE}→${RESET} Generating admin password..."
                
                # Generate admin password and hash
                local admin_password
                admin_password=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-24)
                local admin_hash
                admin_hash=$(docker run --rm authelia/authelia:latest authelia crypto hash generate argon2 --password "$admin_password" | grep "Digest:" | cut -d' ' -f2)
                
                if [[ -n "$admin_hash" ]]; then
                    # Generate OIDC secrets
                    local oidc_hmac_secret immich_client_secret immich_client_secret_hash
                    oidc_hmac_secret=$(openssl rand -base64 32 | tr -d '\n')
                    immich_client_secret=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-24)
                    immich_client_secret_hash=$(docker run --rm authelia/authelia:latest authelia crypto hash generate pbkdf2 --password "$immich_client_secret" | grep "Digest:" | cut -d' ' -f2)
                    
                    # Append Authelia secrets to .env.generated
                    cat >> .env.generated << EOF
# Authelia secrets
AUTHELIA_IDENTITY_VALIDATION_RESET_PASSWORD_JWT_SECRET=$(openssl rand -base64 32 | tr -d '\n')
AUTHELIA_SESSION_SECRET=$(openssl rand -base64 32 | tr -d '\n')
AUTHELIA_STORAGE_ENCRYPTION_KEY=$(openssl rand -base64 32 | tr -d '\n')
AUTHELIA_OIDC_HMAC_SECRET=$oidc_hmac_secret
IMMICH_OIDC_CLIENT_SECRET=$immich_client_secret
IMMICH_OIDC_CLIENT_SECRET_HASH=$immich_client_secret_hash
ADMIN_PASSWORD_HASH='$admin_hash'
EOF
                    
                    echo ""
                    echo -e "${GREEN}✓ ADMIN LOGIN CREDENTIALS:${RESET}"
                    echo -e "   Username: ${YELLOW}admin${RESET}"
                    echo -e "   Password: ${YELLOW}$admin_password${RESET}"
                    echo ""
                    echo -e "${YELLOW}⚠️${RESET}  ${YELLOW}SAVE THIS PASSWORD! It won't be displayed again.${RESET}"
                    echo ""
                    return 0
                else
                    echo -e "${RED}❌ Failed to generate admin password hash${RESET}"
                    return 1
                fi
            fi
            ;;
        caddy)
            if ! service_has_secrets "caddy"; then
                echo -e "${CYAN}🔐${RESET} Generating Caddy secrets..."
                # Add Caddy-specific secrets here if needed
                cat >> .env.generated << EOF

# Caddy secrets
# (Add Caddy-specific secrets here when needed)
EOF
            fi
            ;;
        monitoring)
            if ! service_has_secrets "monitoring"; then
                echo -e "${BLUE}→${RESET} Generating Monitoring secrets..."
                
                # Generate Grafana admin password
                local grafana_password=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-24)
                
                cat >> .env.generated << EOF

# Monitoring secrets
GRAFANA_ADMIN_PASSWORD=${grafana_password}
EOF
                echo -e "${GREEN}✓${RESET} Generated Grafana admin password"
            fi
            ;;
        immich)
            if ! service_has_secrets "immich"; then
                echo -e "${CYAN}🔐${RESET} Generating Immich secrets..."
                
                # Generate database password
                local db_password
                db_password=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-24)
                
                cat >> .env.generated << EOF

# Immich secrets
DB_PASSWORD=$db_password
IMMICH_PASSWORD_LOGIN_ENABLED=true
EOF
                echo -e "${GREEN}✓${RESET} Generated Immich database password"
            fi
            ;;
        *)
            echo -e "${YELLOW}⚠️${RESET}  No specific secrets needed for service: $service"
            ;;
    esac
}

# Setup environment and generate secrets
setup_environment() {
    local environment
    environment=$(detect_environment)
    
    if [[ "$environment" == "unknown" ]]; then
        echo -e "${RED}❌ Cannot detect environment from directory name${RESET}"
        echo -e "${CYAN}ℹ️${RESET}  Run from docker-compose/wroclaw/, docker-compose/kyiv/, docker-compose/oracle/, or docker-compose/frankfurt/ directory"
        return 1
    fi
    
    echo -e "${BLUE}→${RESET} Setting up environment: ${YELLOW}$environment${RESET}"
    echo ""
    
    local admin_password=""
    local secrets_generated=false
    
    # Generate .env.generated if it doesn't exist
    if [[ ! -f ".env.generated" ]]; then
        echo -e "${CYAN}🔐${RESET} Generating secure secrets..."
        cat > .env.generated << EOF
# Auto-generated secrets - DO NOT EDIT MANUALLY
# Generated on $(date)
ENVIRONMENT=$environment
EOF
        
        # Only generate Authelia secrets if authelia service exists
        if service_exists "authelia"; then
            echo -e "${CYAN}👤${RESET} Generating admin password..."
            
            # Generate admin password and hash (like the old Makefile)
            admin_password=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-24)
            local admin_hash
            admin_hash=$(docker run --rm authelia/authelia:latest authelia crypto hash generate argon2 --password "$admin_password" | grep "Digest:" | cut -d' ' -f2)
            
            if [[ -n "$admin_hash" ]]; then
                # Append Authelia secrets to .env.generated
                cat >> .env.generated << EOF

# Authelia secrets
AUTHELIA_IDENTITY_VALIDATION_RESET_PASSWORD_JWT_SECRET=$(openssl rand -base64 32 | tr -d '\n')
AUTHELIA_SESSION_SECRET=$(openssl rand -base64 32 | tr -d '\n')
AUTHELIA_STORAGE_ENCRYPTION_KEY=$(openssl rand -base64 32 | tr -d '\n')
ADMIN_PASSWORD_HASH='$admin_hash'
EOF
                secrets_generated=true
            else
                echo -e "${RED}❌ Failed to generate admin password hash${RESET}"
                return 1
            fi
        fi
    else
        echo -e "${YELLOW}⚠️${RESET}  .env.generated already exists, skipping secret generation"
    fi
    
    # Create .env.user from example if it doesn't exist
    if [[ ! -f ".env.user" && -f ".env.user.example" ]]; then
        echo -e "${CYAN}📝${RESET} Creating .env.user from example..."
        cp .env.user.example .env.user
        echo -e "${GREEN}✅${RESET} Created .env.user from example"
        echo -e "${YELLOW}⚠️${RESET}  Please edit .env.user with your specific configuration"
        echo ""
    fi
    
    # Process all template files (initial setup only)
    process_templates
    
    # Show admin credentials if they were generated
    if [[ -n "$admin_password" && "$secrets_generated" == "true" ]]; then
        echo ""
        echo -e "${GREEN}🔑 ADMIN LOGIN CREDENTIALS:${RESET}"
        echo -e "   Username: ${YELLOW}admin${RESET}"
        echo -e "   Password: ${YELLOW}$admin_password${RESET}"
        echo ""
        echo -e "${YELLOW}⚠️${RESET}  ${YELLOW}SAVE THIS PASSWORD! It won't be displayed again.${RESET}"
        echo ""
    fi
    
    # Show helpful next steps
    local domain_name
    domain_name=$(grep "DOMAIN_NAME=" .env.user 2>/dev/null | cut -d'=' -f2 || echo "")
    
    if [[ -n "$domain_name" && "$domain_name" != "example.com" ]]; then
        echo -e "${GREEN}✅ Setup complete!${RESET}"
        echo -e "${GREEN}🌐${RESET} Domain configured: ${CYAN}$domain_name${RESET}"
    else
        echo -e "${GREEN}✅ Setup complete!${RESET}"
        echo ""
        echo -e "${YELLOW}📝 NEXT STEP: Configure your domain${RESET}"
        echo -e "   Edit .env.user and set DOMAIN_NAME to your domain"
        echo -e "   Example: DOMAIN_NAME=yourdomain.com"
    fi
    echo ""
}

# Service management actions
service_action() {
    local service="$1"
    local action="$2"
    shift 2
    local args=("$@")
    
    if ! service_exists "$service"; then
        msg error "Service not found: $service"
        return 1
    fi
    
    local cmd
    cmd=$(compose_cmd "$service")
    
    case "$action" in
        setup)
            echo -e "${BLUE}→${RESET} Setting up service: ${YELLOW}$service${RESET}"
            # Generate secrets for this service if they don't exist
            generate_service_secrets "$service"
            # Create .env.user from example if it doesn't exist
            if [[ ! -f ".env.user" && -f ".env.user.example" ]]; then
                echo -e "${BLUE}→${RESET} Creating .env.user from example..."
                cp .env.user.example .env.user
                echo -e "${GREEN}✓${RESET} Created .env.user from example"
                echo -e "${YELLOW}⚠️${RESET}  Please edit .env.user with your specific configuration"
                echo ""
            fi
            # Process templates for this service only
            process_templates "$service" false
            echo -e "${GREEN}✓${RESET} Service $service setup complete"
            ;;
        up)
            msg action "Starting $service"
            # Check if templates need processing and ensure secrets exist
            local template_count
            template_count=$(find "$service" -name "*.tmpl" 2>/dev/null | wc -l)
            if [[ $template_count -gt 0 ]]; then
                # Generate secrets if they don't exist for this service
                if ! service_has_secrets "$service"; then
                    msg action "Generating missing secrets..."
                    generate_service_secrets "$service"
                fi
                process_templates "$service" false
            fi
            if [[ ${#args[@]} -eq 0 ]]; then
                $cmd up -d
            else
                $cmd up -d "${args[@]}"
            fi
            
            # Run service-specific post-startup actions
            case "$service" in
                immich)
                    # Run bootstrap script to bypass initial setup screen
                    if [[ -x "immich/bootstrap-admin.sh" ]]; then
                        echo -e "${CYAN}🚀${RESET} Running Immich bootstrap..."
                        if ./immich/bootstrap-admin.sh; then
                            echo -e "${GREEN}✓${RESET} Immich bootstrap completed"
                        else
                            echo -e "${YELLOW}⚠️${RESET} Bootstrap script failed, but service is running"
                        fi
                    fi
                    ;;
            esac
            ;;
        down)
            msg action "Stopping $service"
            if [[ ${#args[@]} -eq 0 ]]; then
                $cmd down
            else
                $cmd down "${args[@]}"
            fi
            ;;
        restart)
            msg action "Restarting $service"
            # Check if templates need processing and ensure secrets exist
            local template_count
            template_count=$(find "$service" -name "*.tmpl" 2>/dev/null | wc -l)
            if [[ $template_count -gt 0 ]]; then
                # Generate secrets if they don't exist for this service
                if ! service_has_secrets "$service"; then
                    msg action "Generating missing secrets..."
                    generate_service_secrets "$service"
                fi
                process_templates "$service" false
            fi
            if [[ ${#args[@]} -eq 0 ]]; then
                $cmd restart
            else
                $cmd restart "${args[@]}"
            fi
            ;;
        logs)
            if [[ ${#args[@]} -eq 0 ]]; then
                $cmd logs --tail=50
            else
                $cmd logs --tail=50 "${args[@]}"
            fi
            ;;
        status)
            if [[ ${#args[@]} -eq 0 ]]; then
                $cmd ps
            else
                $cmd ps "${args[@]}"
            fi
            ;;
        clean)
            msg action "Cleaning $service"
            $cmd down 2>/dev/null || true
            service_clean "$service"
            remove_service_secrets "$service"
            echo -e "${GREEN}✓${RESET} Service $service cleanup complete"
            ;;
        *)
            msg error "Unknown action: $action"
            return 1
            ;;
    esac
}

# Service-specific actions
service_specific_action() {
    local service="$1"
    local action="$2"
    shift 2
    local args=("$@")
    
    case "$service" in
        authelia)
            case "$action" in
                get-code)
                    msg action "Extracting Authelia verification code"
                    if [[ -f "authelia/config/notification.txt" ]]; then
                        local code
                        code=$(grep -E "^[A-Z0-9]{8}$" authelia/config/notification.txt | tail -n 1)
                        if [[ -n "$code" ]]; then
                            msg success "Latest verification code: $code"
                        else
                            msg warning "No verification code found in notification.txt"
                        fi
                    else
                        msg error "Notification file not found: authelia/config/notification.txt"
                        return 1
                    fi
                    ;;
                generate-secrets)
                    msg action "Generating new Authelia secrets"
                    if [[ ! -f ".env.generated" ]]; then
                        msg error ".env.generated file not found. Run './deploy setup' first."
                        return 1
                    fi
                    
                    # Generate new secrets
                    local jwt_secret session_secret storage_secret
                    jwt_secret=$(openssl rand -base64 32 | tr -d '\n')
                    session_secret=$(openssl rand -base64 32 | tr -d '\n')
                    storage_secret=$(openssl rand -base64 32 | tr -d '\n')
                    
                    # Update .env.generated file
                    sed -i.bak "s|AUTHELIA_IDENTITY_VALIDATION_RESET_PASSWORD_JWT_SECRET=.*|AUTHELIA_IDENTITY_VALIDATION_RESET_PASSWORD_JWT_SECRET=$jwt_secret|g" .env.generated
                    sed -i.bak "s|AUTHELIA_SESSION_SECRET=.*|AUTHELIA_SESSION_SECRET=$session_secret|g" .env.generated
                    sed -i.bak "s|AUTHELIA_STORAGE_ENCRYPTION_KEY=.*|AUTHELIA_STORAGE_ENCRYPTION_KEY=$storage_secret|g" .env.generated
                    rm -f .env.generated.bak
                    
                    msg success "New secrets generated in .env.generated"
                    msg warning "You will need to remove the database: './deploy authelia clean-db'"
                    ;;
                generate-password)
                    local password="${args[0]:-}"
                    if [[ -z "$password" ]]; then
                        password=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-24)
                        echo -e "${CYAN}🎲${RESET} Generated random password: ${YELLOW}$password${RESET}"
                    else
                        echo -e "${CYAN}🔑${RESET} Using provided password"
                    fi
                    
                    echo -e "${CYAN}⚒️${RESET}  Generating password hash for admin user..."
                    local hash
                    hash=$(docker run --rm authelia/authelia:latest authelia crypto hash generate argon2 --password "$password" | grep "Digest:" | cut -d' ' -f2)
                    
                    if [[ -n "$hash" ]]; then
                        # Update password hash in .env.generated
                        if [[ -f ".env.generated" ]]; then
                            sed -i.bak "s|ADMIN_PASSWORD_HASH=.*|ADMIN_PASSWORD_HASH='$hash'|g" .env.generated
                            rm -f .env.generated.bak
                        fi
                        
                        echo ""
                        echo -e "${GREEN}🔑 ADMIN LOGIN CREDENTIALS:${RESET}"
                        echo -e "   Username: ${YELLOW}admin${RESET}"
                        echo -e "   Password: ${YELLOW}$password${RESET}"
                        echo ""
                        echo -e "${YELLOW}⚠️${RESET}  ${YELLOW}SAVE THIS PASSWORD! It won't be displayed again.${RESET}"
                        echo -e "${GREEN}✅${RESET} Password hash updated in .env.generated"
                        echo ""
                    else
                        echo -e "${RED}❌ Failed to generate password hash${RESET}"
                        return 1
                    fi
                    ;;
                clean-db)
                    msg action "Removing Authelia database"
                    # Stop containers first
                    local cmd
                    cmd=$(compose_cmd "authelia")
                    $cmd down 2>/dev/null || true
                    
                    # Remove database file
                    if [[ -f "authelia/config/db.sqlite3" ]]; then
                        rm -f authelia/config/db.sqlite3
                        msg success "Database removed. Run './deploy authelia up' to recreate it."
                    else
                        msg info "Database file not found (already removed or never created)"
                    fi
                    ;;
                *)
                    msg error "Unknown Authelia action: $action"
                    return 1
                    ;;
            esac
            ;;
        caddy)
            case "$action" in
                validate)
                    msg action "Validating Caddyfile"
                    if [[ -f "caddy/config/Caddyfile" ]]; then
                        # Use Caddy container to validate
                        docker run --rm -v "$(pwd)/caddy/config/Caddyfile:/etc/caddy/Caddyfile:ro" caddy:latest caddy validate --config /etc/caddy/Caddyfile
                        msg success "Caddyfile is valid"
                    else
                        msg error "Caddyfile not found at caddy/config/Caddyfile"
                        return 1
                    fi
                    ;;
                *)
                    msg error "Unknown Caddy action: $action"
                    return 1
                    ;;
            esac
            ;;
        monitoring)
            case "$action" in
                backup)
                    msg action "Backing up monitoring data"
                    # Implementation needed
                    msg warning "backup action not yet implemented"
                    ;;
                generate-secrets)
                    msg action "Regenerating monitoring secrets"
                    
                    # Remove existing monitoring secrets from .env.generated
                    if [[ -f .env.generated ]]; then
                        sed -i.bak '/^# Monitoring secrets/,/^$/d' .env.generated
                        rm -f .env.generated.bak
                    fi
                    
                    # Generate new Grafana admin password
                    local grafana_password=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-24)
                    
                    cat >> .env.generated << EOF

# Monitoring secrets
GRAFANA_ADMIN_PASSWORD=${grafana_password}
EOF
                    msg success "Generated new Grafana admin password: ${grafana_password}"
                    msg info "Password saved to .env.generated"
                    ;;
                *)
                    msg error "Unknown monitoring action: $action"
                    return 1
                    ;;
            esac
            ;;
        *)
            msg error "Service $service does not have specific action: $action"
            return 1
            ;;
    esac
}

# Service-specific clean operations
service_clean() {
    local service="$1"
    
    case "$service" in
        authelia)
            # Remove database and notification files but keep config
            [[ -f "authelia/config/db.sqlite3" ]] && echo -e "  ${CYAN}•${RESET} authelia/config/db.sqlite3" && rm -f authelia/config/db.sqlite3
            [[ -f "authelia/config/notification.txt" ]] && echo -e "  ${CYAN}•${RESET} authelia/config/notification.txt" && rm -f authelia/config/notification.txt
            [[ -f "authelia/config/users_database.yml" ]] && echo -e "  ${CYAN}•${RESET} authelia/config/users_database.yml" && rm -f authelia/config/users_database.yml
            [[ -f "authelia/config/configuration.yml" ]] && echo -e "  ${CYAN}•${RESET} authelia/config/configuration.yml" && rm -f authelia/config/configuration.yml
            # Remove data directories content but keep structure
            if [[ -d "authelia/data" && -n "$(ls -A authelia/data 2>/dev/null)" ]]; then
                echo -e "  ${CYAN}•${RESET} authelia/data/* (contents)"
                rm -rf authelia/data/*
            fi
            if [[ -d "authelia/redis-data" && -n "$(ls -A authelia/redis-data 2>/dev/null)" ]]; then
                echo -e "  ${CYAN}•${RESET} authelia/redis-data/* (contents)"
                rm -rf authelia/redis-data/*
            fi
            ;;
        caddy)
            # Remove Caddy data but keep config
            if [[ -d "caddy/data" ]]; then
                rm -rf caddy/data/* 2>/dev/null || true
            fi
            ;;
        monitoring)
            # Remove monitoring secrets from .env.generated
            if [[ -f ".env.generated" ]] && grep -q "# Monitoring secrets" .env.generated; then
                remove_service_secrets "monitoring"
            fi
            
            # Note: Monitoring data cleanup not implemented - too risky for data loss
            # Only secrets are removed, data in monitoring/ directories is preserved
            ;;
        immich)
            # Remove Immich Docker volumes for complete reset
            echo -e "  ${CYAN}•${RESET} Removing Docker volumes..."
            
            # Check if volumes exist before attempting to remove them
            local volumes_to_remove=()
            for volume in immich_immich_postgres_data immich_model-cache; do
                if docker volume ls -q | grep -q "^${volume}$"; then
                    volumes_to_remove+=("$volume")
                fi
            done
            
            if [[ ${#volumes_to_remove[@]} -gt 0 ]]; then
                echo -e "  ${CYAN}•${RESET} Found volumes: ${volumes_to_remove[*]}"
                if docker volume rm "${volumes_to_remove[@]}" 2>/dev/null; then
                    echo -e "  ${GREEN}✓${RESET} Removed Docker volumes: ${volumes_to_remove[*]}"
                else
                    echo -e "  ${YELLOW}⚠️${RESET} Some volumes may still be in use. Stop the service first."
                fi
            else
                echo -e "  ${CYAN}•${RESET} No Immich volumes found to remove"
            fi
            
            # Remove generated config files
            [[ -f "immich/config/immich.json" ]] && echo -e "  ${CYAN}•${RESET} immich/config/immich.json" && rm -f immich/config/immich.json
            
            # Clean upload directory contents but keep structure  
            if [[ -d "immich/upload" && -n "$(ls -A immich/upload 2>/dev/null)" ]]; then
                echo -e "  ${CYAN}•${RESET} immich/upload/* (contents)"
                rm -rf immich/upload/*
            fi
            ;;
        *)
            # No specific clean operation for this service
            ;;
    esac
}

# Apply action to all services
all_services_action() {
    local action="$1"
    shift
    local args=("$@")
    
    local services
    # Use read loop instead of mapfile for compatibility
    services=()
    while IFS= read -r service; do
        services+=("$service")
    done < <(discover_services)
    
    if [[ ${#services[@]} -eq 0 ]]; then
        msg warning "No services found in current directory"
        return 1
    fi
    
    local failed=0
    for service in "${services[@]}"; do
        if [[ ${#args[@]} -eq 0 ]]; then
            if ! service_action "$service" "$action"; then
                ((failed++))
            fi
        else
            if ! service_action "$service" "$action" "${args[@]}"; then
                ((failed++))
            fi
        fi
    done
    
    if [[ $failed -gt 0 ]]; then
        msg error "$failed service(s) failed"
        return 1
    fi
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        return 1
    fi
    
    local environment
    environment=$(detect_environment)
    
    if [[ "$environment" == "unknown" ]]; then
        msg warning "Unknown environment directory: $(basename "$(pwd)")"
        msg info "Expected: docker-compose/wroclaw, docker-compose/kyiv, docker-compose/oracle, or docker-compose/frankfurt"
    fi
    
    local first_arg="$1"
    
    # Check if first argument is a service
    if service_exists "$first_arg"; then
        local service="$1"
        local action="${2:-help}"
        shift 2
        local args=("$@")
        
        if [[ "$action" == "help" ]]; then
            show_help "$service"
            return 0
        fi
        
        # Check if it's a standard action
        case "$action" in
            setup|up|down|restart|logs|status|clean)
                if [[ ${#args[@]} -eq 0 ]]; then
                    service_action "$service" "$action"
                else
                    service_action "$service" "$action" "${args[@]}"
                fi
                ;;
            *)
                # Try service-specific action
                if [[ ${#args[@]} -eq 0 ]]; then
                    service_specific_action "$service" "$action"
                else
                    service_specific_action "$service" "$action" "${args[@]}"
                fi
                ;;
        esac
    else
        # First argument is an action for all services
        local action="$first_arg"
        shift
        local args=("$@")
        
        case "$action" in
            setup)
                setup_environment
                ;;
            up|down|restart|logs|status|clean)
                if [[ ${#args[@]} -eq 0 ]]; then
                    all_services_action "$action"
                else
                    all_services_action "$action" "${args[@]}"
                fi
                ;;
            help|--help|-h)
                show_help
                ;;
            *)
                msg error "Unknown action or service: $action"
                msg info "Available services: $(discover_services | tr '\n' ' ')"
                msg info "Available actions: setup, up, down, restart, logs, status, clean, help"
                return 1
                ;;
        esac
    fi
}

# Run main function with all arguments
main "$@"